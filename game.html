<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Mario-like Stage 1 (Fahmi)</title>
<style>
  :root{--bg:#7ec0ee;--ground:#6aa84f;--ui:#0b1220}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;color:#111}
  body{display:flex;align-items:center;justify-content:center;background:linear-gradient(#7ec0ee,#9fd6ff);padding:12px}
  .wrap{width:min(980px,98vw);max-width:980px;background:linear-gradient(#eaf6ff,#dff5ff);border-radius:12px;box-shadow:0 20px 50px rgba(8,18,30,.15);overflow:hidden}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 14px;background:var(--ui);color:white}
  header .title{font-weight:700}
  #gameCanvas{display:block;background:linear-gradient(#92d3ff,#8cc8ff);width:100%;height:480px}
  .controls{display:flex;gap:8px;align-items:center;padding:10px;background:#fff7;border-top:1px solid #0000}
  .btn{padding:8px 12px;border-radius:8px;border:0;background:#111;color:#fff;font-weight:700;cursor:pointer}
  .hint{color:#333;font-size:13px}
  /* mobile touch buttons */
  .touchpad{position:absolute;bottom:18px;left:14px;display:flex;gap:6px}
  .touchbtn{width:56px;height:56px;border-radius:12px;background:#ffffffcc;border:1px solid #00000010;display:grid;place-items:center;font-weight:800}
  .touch-right{position:absolute;right:12px;bottom:18px}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">Fahmi's Stage 1 ‚Äî Mini Platformer</div>
      <div style="display:flex;gap:10px;align-items:center">
        <div id="score">Score: 0</div>
        <div id="lives">Lives: 3</div>
      </div>
    </header>

    <canvas id="gameCanvas" width="960" height="480"></canvas>

    <div class="controls">
      <div class="hint">Controls: ‚Üê ‚Üí or A/D to move, ‚Üë / W / Space to jump. On mobile use buttons.</div>
      <div style="margin-left:auto">
        <button class="btn" id="restartBtn">Restart</button>
      </div>
    </div>

    <!-- mobile touch -->
    <div class="touchpad" id="touchpad" style="pointer-events:auto">
      <div class="touchbtn" id="leftBtn">‚óÄ</div>
      <div class="touchbtn" id="rightBtn">‚ñ∂</div>
      <div class="touchbtn" id="jumpBtn" style="width:56px">‚ñ≤</div>
    </div>
  </div>

<script>
/* ===========================
   Mini Mario-like Stage 1
   - Canvas game with tile map
   - Player physics, collisions, enemies, coins, goal
   - Simple scrolling camera
   - Touch controls for mobile
   =========================== */
   // // // // // //

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// ---- Config / tiles ----
const TILE = 32; // tile size (px)
const GRAVITY = 1200; // px/s^2
const MOVE_SPEED = 220; // px/s
const JUMP_SPEED = 520; // initial jump velocity px/s

// ---- Simple assets: We'll draw pixels / shapes. You can replace with images later ----
const assets = {
  // placeholder: create small offscreen canvases for sprites
  player: makePlayerSprite(),
  enemy: makeEnemySprite(),
  coin: makeCoinSprite(),
  gift: makeGiftSprite(),
  tiles: makeTileSprites()
};

// ---- Level map: array of strings - '.' empty, '#' ground, 'b' block, 'e' enemy spawn, 'c' coin, 'g' gift/goal ----
// Make a level longer than screen (wide)
const levelRows = 12;
const levelCols = 200; // long level: 200 tiles
let level = Array.from({length: levelRows},()=>'.'.repeat(levelCols).split(''));

// helper: fill base ground at bottom 2 rows
for(let x=0;x<levelCols;x++){
  level[levelRows-1][x] = '#';
  level[levelRows-2][x] = '#';
}
// create some platforms & obstacles for variety
function placeRect(tx, ty, w, h, ch){
  for(let x=tx;x<tx+w;x++) for(let y=ty;y<ty+h;y++) if(x>=0 && x<levelCols && y>=0 && y<levelRows) level[y][x]=ch;
}
// platforms
placeRect(10,8,6,1,'b');
placeRect(18,6,8,1,'b');
placeRect(30,9,4,1,'b');
placeRect(38,7,5,1,'b');
placeRect(48,6,8,1,'b');
placeRect(60,9,5,1,'b');
placeRect(72,7,6,1,'b');
placeRect(88,8,7,1,'b');
placeRect(120,6,10,1,'b');
placeRect(150,8,6,1,'b');
placeRect(170,5,8,1,'b');

// coins above some platforms
[['c',12,7],['c',20,5],['c',31,8],['c',39,6],['c',50,5],['c',61,8],['c',73,6],['c',89,7],['c',121,4],['c',151,7]].forEach(([ch,x,y])=>{ level[y][x]=ch; });

// enemies
[['e',22,9],['e',55,9],['e',95,9],['e',160,9]].forEach(([,x,y])=>{ level[y][x]='e'; });

// pit: carve ground away to make jumping challenge
for(let i=130;i<136;i++){ level[levelRows-1][i]='.'; level[levelRows-2][i]='.'; }
// place goal gift near end
level[ levelRows-3 ][ levelCols-6 ] = 'g';

// ---- Camera & Player state ----
let cameraX = 0;
const VIEW_W = W, VIEW_H = H;

const player = {
  x: TILE * 2,
  y: (levelRows-3) * TILE - 64,
  w: 28, h: 40,
  vx: 0, vy: 0,
  onGround: false,
  facing: 1,
  anim: 0
};

let keys = {};
let score = 0;
let lives = 3;
let gameOver = false;
let levelFinished = false;

// ---- Input handlers ----
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if([' ','arrowup','w'].includes(e.key.toLowerCase())) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// Touch buttons
function bindTouch(id, key){
  const el = document.getElementById(id);
  el.addEventListener('touchstart', e=>{ e.preventDefault(); keys[key]=true; }, {passive:false});
  el.addEventListener('touchend', e=>{ e.preventDefault(); keys[key]=false; }, {passive:false});
}
bindTouch('leftBtn','arrowleft');
bindTouch('rightBtn','arrowright');
bindTouch('jumpBtn','arrowup');

// Restart
document.getElementById('restartBtn').addEventListener('click', ()=> location.reload());

// ---- Utility tile checking ----
function tileAt(px,py){
  const tx = Math.floor(px / TILE);
  const ty = Math.floor(py / TILE);
  if(ty<0||ty>=levelRows||tx<0||tx>=levelCols) return '.';
  return level[ty][tx];
}
function setTile(tx,ty,val){ if(ty>=0&&ty<levelRows&&tx>=0&&tx<levelCols) level[ty][tx]=val; }

// ---- Game loop ----
let last = performance.now();
function loop(now){
  let dt = (now-last)/1000; if(dt>0.05) dt=0.05; last=now;
  update(dt); render();
  if(!gameOver) requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ---- Update physics & logic ----
function update(dt){
  if(gameOver || levelFinished) return;

  // input
  let left = keys['arrowleft'] || keys['a'];
  let right = keys['arrowright'] || keys['d'];
  let up = keys['arrowup'] || keys['w'] || keys[' '];

  // horizontal
  if(left){ player.vx = -MOVE_SPEED; player.facing = -1; }
  else if(right){ player.vx = MOVE_SPEED; player.facing = 1; }
  else player.vx = 0;

  // jump
  if(up && player.onGround){
    player.vy = -JUMP_SPEED;
    player.onGround = false;
  }

  // apply gravity
  player.vy += GRAVITY * dt;

  // integrate
  player.x += player.vx * dt;
  player.y += player.vy * dt;

  // collisions: tile-based AABB collision resolution
  player.onGround = false;
  // clamp within level horizontal bounds
  if(player.x < 0) player.x = 0;
  // check vertical collisions with tiles
  resolveTileCollisions(player);

  // enemy collisions & coin pickup & goal
  checkEntities();

  // camera: center on player but clamp
  cameraX = Math.floor(player.x - VIEW_W/3);
  cameraX = Math.max(0, Math.min(cameraX, levelCols*TILE - VIEW_W));

  // update UI
  document.getElementById('score').innerText = 'Score: '+score;
  document.getElementById('lives').innerText = 'Lives: '+lives;

  // if player falls below screen -> lose life / respawn
  if(player.y > levelRows * TILE + 200){
    loseLife();
  }
}

// resolve collisions with solid tiles ('#' and 'b')
function resolveTileCollisions(ent){
  // sample a small rectangle of possible colliding tiles
  const left = Math.floor((ent.x) / TILE);
  const right = Math.floor((ent.x + ent.w) / TILE);
  const top = Math.floor((ent.y) / TILE);
  const bottom = Math.floor((ent.y + ent.h) / TILE);

  // iterate tiles overlapping bounding box
  for(let ty=top; ty<=bottom; ty++){
    for(let tx=left; tx<=right; tx++){
      if(tx<0||ty<0||tx>=levelCols||ty>=levelRows) continue;
      const ch = level[ty][tx];
      if(ch === '#' || ch === 'b'){
        // tile rectangle
        const rx = tx*TILE, ry = ty*TILE, rw = TILE, rh = TILE;
        if(aabbIntersect(ent.x, ent.y, ent.w, ent.h, rx, ry, rw, rh)){
          // calculate overlap on x and y
          const overlapX1 = (ent.x + ent.w) - rx; // from left
          const overlapX2 = (rx + rw) - ent.x; // from right
          const overlapY1 = (ent.y + ent.h) - ry; // from top
          const overlapY2 = (ry + rh) - ent.y; // from bottom
          // pick smallest penetration
          const minX = Math.min(overlapX1, overlapX2);
          const minY = Math.min(overlapY1, overlapY2);
          if(minX < minY){
            // push horizontally
            if(overlapX1 < overlapX2){
              ent.x -= overlapX1;
            } else {
              ent.x += overlapX2;
            }
            ent.vx = 0;
          } else {
            // push vertically
            if(overlapY1 < overlapY2){
              ent.y -= overlapY1;
              ent.vy = 0;
              ent.onGround = true;
            } else {
              ent.y += overlapY2;
              ent.vy = 0;
            }
          }
        }
      }
    }
  }
}
function aabbIntersect(x1,y1,w1,h1,x2,y2,w2,h2){
  return !(x1+w1 <= x2 || x2+w2 <= x1 || y1+h1 <= y2 || y2+h2 <= y1);
}

// ---- Entities: enemies & coins & gift ----
let enemies = [];
let coins = [];
let gift = {x: (levelCols-6)*TILE, y:(levelRows-3)*TILE - 28, w:32,h:32, collected:false};

// populate enemies & coins by scanning level map
function scanLevelForEntities(){
  enemies = []; coins = [];
  for(let y=0;y<levelRows;y++){
    for(let x=0;x<levelCols;x++){
      const ch = level[y][x];
      if(ch === 'e'){
        enemies.push({x:x*TILE,y:y*TILE- (32),w:28,h:28,dir:-1,spd:60,alive:true});
        level[y][x]='.'; // clear tile so enemy not treated as tile
      } else if(ch === 'c'){
        coins.push({x:x*TILE+8,y:y*TILE+8,w:16,h:16,got:false});
        level[y][x]='.';
      } else if(ch === 'g'){
        // already placed gift
        level[y][x]='.';
      }
    }
  }
}
scanLevelForEntities();

// update entities and check collisions with player
function checkEntities(){
  // move enemies
  enemies.forEach(en => {
    if(!en.alive) return;
    en.x += en.spd * en.dir * (1/60);
    // simple collision with ground tiles (reverse if bump)
    const belowTile = tileAt(en.x + en.w/2, en.y + en.h + 2);
    if(belowTile === '.') {
      // fall
      en.y += 2;
    }
    // reverse if hit a solid tile ahead
    const ahead = tileAt(en.x + (en.dir>0?en.w+2:-4), en.y + en.h/2);
    if(ahead === '#' || ahead === 'b') en.dir *= -1;
    // check player collision
    if(aabbIntersect(player.x,player.y,player.w,player.h, en.x,en.y,en.w,en.h)){
      // if player falling onto enemy -> kill enemy
      if(player.vy > 0 && (player.y + player.h) - en.y < 18){
        en.alive = false;
        score += 100;
        player.vy = -JUMP_SPEED*0.5; // bounce
      } else {
        // hit player -> lose life
        loseLife();
      }
    }
  });

  // coins pickup
  coins.forEach(c => {
    if(!c.got && aabbIntersect(player.x,player.y,player.w,player.h, c.x,c.y,c.w,c.h)){
      c.got = true; score += 10;
    }
  });

  // gift / goal
  if(!gift.collected && aabbIntersect(player.x,player.y,player.w,player.h, gift.x,gift.y,gift.w,gift.h)){
    gift.collected = true;
    levelFinished = true;
    // show win overlay
    setTimeout(()=> {
      showWin();
    }, 200);
  }
}

// lose life handler
function loseLife(){
  lives--;
  if(lives<=0){
    gameOver = true;
    showGameOver();
  } else {
    // respawn player near start
    player.x = TILE*2; player.y = (levelRows-3)*TILE - player.h; player.vx=0; player.vy=0;
  }
}

// ---- Rendering ----
function render(){
  // clear
  ctx.clearRect(0,0,W,H);

  // sky gradient background
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#9fd6ff'); g.addColorStop(1,'#8cc8ff');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // draw tiles (only visible area)
  const startCol = Math.floor(cameraX / TILE);
  const endCol = Math.ceil((cameraX + VIEW_W) / TILE);
  for(let y=0;y<levelRows;y++){
    for(let x=startCol; x<endCol; x++){
      if(x<0||x>=levelCols) continue;
      const ch = level[y][x];
      const screenX = x*TILE - cameraX;
      const screenY = y*TILE;
      if(ch === '#'){
        drawTile(screenX, screenY, 'ground');
      } else if(ch === 'b'){
        drawTile(screenX, screenY, 'brick');
      }
    }
  }

//
  // draw coins
  coins.forEach(c=>{
    if(!c.got) drawSprite(assets.coin, c.x - cameraX, c.y, c.w, c.h);
  });

  // draw enemies
  enemies.forEach(en=>{
    if(!en.alive) return;
    drawSprite(assets.enemy, en.x - cameraX, en.y, en.w, en.h);
  });

  // draw gift
  if(!gift.collected) drawSprite(assets.gift, gift.x - cameraX, gift.y, gift.w, gift.h);

  // draw player (with name above)
  // name
  ctx.font = 'bold 16px Arial';
  ctx.fillStyle = 'white';
  ctx.strokeStyle = '#0008';
  ctx.lineWidth = 2;
  const name = 'Fahmi';
  const px = player.x - cameraX + player.w/2;
  ctx.strokeText(name, px - ctx.measureText(name).width/2, player.y - 10);
  ctx.fillText(name, px - ctx.measureText(name).width/2, player.y - 10);

  // player sprite
  drawSprite(assets.player, player.x - cameraX, player.y, player.w, player.h);

  // UI: lives / score are in DOM header, optionally can draw minimap etc.
}

// helper draw sprite (assets are canvases)
function drawSprite(sprite, x, y, w, h){
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(sprite, 0, 0, sprite.width, sprite.height, Math.round(x), Math.round(y), w, h);
}

// simple tile drawing using assets.tiles
function drawTile(x,y,type){
  if(type === 'ground'){
    ctx.drawImage(assets.tiles.ground, x, y, TILE, TILE);
  } else if(type === 'brick'){
    ctx.drawImage(assets.tiles.brick, x, y, TILE, TILE);
  }
}

// ---- UI overlays ----
function showGameOver(){
  // big overlay
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = 'white';
  ctx.font = 'bold 36px Arial';
  ctx.fillText('Game Over', W/2 - 100, H/2 - 10);
  ctx.font = '20px Arial';
  ctx.fillText('Refresh untuk coba lagi', W/2 - 110, H/2 + 24);
}
function showWin(){
  // overlay celebration
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = 'white';
  ctx.font = 'bold 32px Arial';
  ctx.fillText('üéâ Selamat Fahmi! Kamu menang!', W/2 - 220, H/2 - 10);
  ctx.font = '20px Arial';
  ctx.fillText('Kado menantimu di ujung. Tekan Restart untuk main lagi.', W/2 - 260, H/2 + 28);
}

// ---- Helper: make placeholder pixel sprites as canvases (so no external files) ----
function makePlayerSprite(){
  const c = document.createElement('canvas'); c.width=16; c.height=24; const r = c.getContext('2d');
  r.imageSmoothingEnabled=false;
  // draw a simple pixel person (head, body, legs)
  // head
  r.fillStyle='#f1c27d'; r.fillRect(6,0,4,4);
  // hat/hair
  r.fillStyle='#111'; r.fillRect(5,0,6,2);
  // body
  r.fillStyle='#2b6fb4'; r.fillRect(4,4,8,9);
  // left arm
  r.fillStyle='#2b6fb4'; r.fillRect(2,6,3,4);
  // legs
  r.fillStyle='#2b2b2b'; r.fillRect(4,13,3,7); r.fillRect(9,13,3,7);
  return c;
}
function makeEnemySprite(){
  const c = document.createElement('canvas'); c.width=16; c.height=16; const r = c.getContext('2d');
  r.fillStyle='#8b0000'; r.fillRect(0,6,16,8); r.fillStyle='#000'; r.fillRect(2,2,4,2); r.fillRect(10,2,4,2);
  return c;
}
function makeCoinSprite(){
  const c = document.createElement('canvas'); c.width=12; c.height=12; const r=c.getContext('2d');
  r.beginPath(); r.fillStyle='#ffd700'; r.arc(6,6,5,0,Math.PI*2); r.fill(); return c;
}
function makeGiftSprite(){
  const c = document.createElement('canvas'); c.width=20; c.height=20; const r=c.getContext('2d');
  // box
  r.fillStyle='#b22222'; r.fillRect(2,6,16,12);
  // ribbon vertical
  r.fillStyle='#ffd700'; r.fillRect(9,6,3,12);
  // ribbon horizontal
  r.fillRect(2,12,16,3);
  return c;
}
function makeTileSprites(){
  const tiles = {ground: null, brick: null};
  // ground tile
  const g = document.createElement('canvas'); g.width=TILE; g.height=TILE; const gr=g.getContext('2d');
  // green dirt block with top highlight
  gr.fillStyle='#5aa64a'; gr.fillRect(0,0,TILE,TILE);
  gr.fillStyle='#4a8b3b'; gr.fillRect(0,TILE-8,TILE,8);
  tiles.ground=g;
  // brick
  const b = document.createElement('canvas'); b.width=TILE; b.height=TILE; const br=b.getContext('2d');
  br.fillStyle='#b5651d'; br.fillRect(0,0,TILE,TILE);
  br.fillStyle='#9a4e14'; for(let i=0;i<3;i++) br.fillRect(2+i*10,6,6,6);
  tiles.brick=b;
  return tiles;
}

/* ===========================
   Notes:
   - To replace sprites with PNGs: create Image(), set src, and use ctx.drawImage(image,...).
   - Level is tile-based; you can edit 'level' variable or helper placeRect to design custom stage.
   =========================== */
</script>
</body>
</html>
